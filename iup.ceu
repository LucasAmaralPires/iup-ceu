data :Iup = [h] {
    :Action = [] {
        :List = []
    }
    :Value = []
}

```:pre
#include <iup.h>
int iup_action_cb (Ihandle* h) {
    CEU_Value evt = ceu_create_tuple(1);
    CEU_Value tag = { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iup_Action} };
    ceu_tags_set(evt, tag, 1);
    ceu_tuple_set(&evt.Dyn->Tuple, 0, (CEU_Value) { CEU_VALUE_POINTER, {.Pointer=h} });
    ceux_push(CEU_GLOBAL_X->S, 1, evt);
    ceu_broadcast_global();
    ceux_pop(CEU_GLOBAL_X->S, 1);
    return IUP_DEFAULT;
}

int iup_value_cb (Ihandle* h) {
puts("-=-=-");
    CEU_Value evt = ceu_create_tuple(1);
    CEU_Value tag = { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iup_Value} };
    ceux_push(CEU_GLOBAL_X->S, 1, evt);
    ceu_broadcast_global();
    ceux_pop(CEU_GLOBAL_X->S, 1);
    return IUP_DEFAULT;
}

int iup_list_action_cb (Ihandle* h, char *text, int item, int state) {
    //CEU_Value it = { CEU_VALUE_NUMBER,  {.Number=item} };
    //CEU_Value st = { CEU_VALUE_BOOL,    {.Bool=state} };
    CEU_Value hh = { CEU_VALUE_POINTER, {.Pointer=h} };
    CEU_Value tag = { CEU_VALUE_TAG, {.Tag=CEU_TAG_Iup_Action_List} };
    int ret = ceu_bcast_tasks(CEU_GLOBAL_X, CEU_ACTION_RESUME, CEU_TIME, (CEU_Dyn*) &CEU_GLOBAL_TASK);
    assert(ret == 0);
    return IUP_DEFAULT;
}
```

;; INIT

func iup_loop () {
    `IupMainLoop();`
}

;; GET / SET

func iup_get_pointer (h, name) {
    val s = to-pointer(name)
    `:pointer IupGetAttribute($h.Pointer, $s.Pointer+1)`
}
func iup_get_bool (h, name) {
    val s = to-pointer(name)
    `:bool IupGetInt($h.Pointer, $s.Pointer+1)`
}
func iup_get_number (h, name) {
    val s = to-pointer(name)
    `:number IupGetInt($h.Pointer, $s.Pointer+1)`
}

func iup_set(h, name, value) {
    val s = to-pointer(name)
    ifs value {
        :bool    => `IupSetInt($h.Pointer, $s.Pointer+1, $value.Bool);`
        :number  => `IupSetFloat($h.Pointer, $s.Pointer+1, $value.Number);`
        :tag     => `IupSetAttribute($h.Pointer, $s.Pointer+1, $t.Pointer+1);`
            where {
                val t = to-pointer(value)
            }
        else     => `IupSetStrAttribute($h.Pointer, $s.Pointer+1, $v.Pointer);`
            where {
                val v = to-pointer(value)
println(:x, name, value)
println(:y, v, to-string(v))
            }
    }
}

;; CONTROLS

;;;
func iup_action_cb (h) {
    broadcast( @[(:obj,h),(:type,:action)] )
        in :global
}
func iup_value_cb (h) {
    broadcast( @[(:obj,h),(:type,:value)]  )
        in :global
}
func iup_list_action_cb (h, item, state) {
    broadcast( @[(:obj,h),(:type,:action),(:item,item),(:state,state)] )
        in :global
}
;;;

func iup_button (label) {
    val s = to-pointer(label)
    val h = `:pointer IupButton($s.Pointer, NULL)`
    `IupSetCallback($h.Pointer, "ACTION", iup_action_cb);`
    h
}

func iup_label (label) {
    val s = to-pointer(label)
    `:pointer IupLabel($s.Pointer)`
}

func iup_list () {
    val h = `:pointer IupList(NULL)`
    `IupSetCallback($h.Pointer, "ACTION", (Icallback) iup_list_action_cb);`
    h
}

func iup_text () {
    val h = `:pointer IupText(NULL)`
    `IupSetCallback($h.Pointer, "VALUECHANGED_CB", iup_value_cb);`
    h
}

;; CONTAINERS

func iup_hbox () {
    `:pointer IupHbox(NULL)`
}

func iup_vbox () {
    `:pointer IupVbox(NULL)`
}

func iup_append (h, child) {
    `:pointer IupAppend($h.Pointer, $child.Pointer)`
}

;; DIALOGS

func iup_dialog (h) {
    `:pointer IupDialog($h.Pointer)`
}

func iup_show_xy (h, x, y) {
    `:number IupShowXY($h.Pointer, $x.Number, $y.Number)`
}

;; MAIN

`IupOpen(NULL,NULL);`
defer {
    `IupClose();`
}
