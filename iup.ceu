native type _{
    #include <iup.h>
}

type Event = <
    Kill = (),
    Task = _uint64_t,
    None = (),
    Iup  = <    -- TODO: inheritance _(Ihandle*) + ...
        Button = _(Ihandle*),
        List   = [self:_(Ihandle*), text:_(char*), item:_int, state:_int],
        Text   = _(Ihandle*)
    >
>

var isEventButton = func [e:/Event, but:_(Ihandle*)] -> _int {
    if not arg.e\?Iup        { return _0 }
    if not arg.e\!Iup?Button { return _0 }
    return or [
            leq [_0:_long,arg.but::_long],
            leq [arg.e\!Iup!Button::_long,arg.but::_long]
           ]
}

var isEventList = func [e:/Event, lst:_(Ihandle*)] -> _int {
    if not arg.e\?Iup      { return _0 }
    if not arg.e\!Iup?List { return _0 }
    return or [
            leq [_0:_long,arg.lst::_long],
            leq [arg.e\!Iup!List.1::_long,arg.lst::_long]
           ]
}

var isEventText = func [e:/Event, txt:_(Ihandle*)] -> _int {
    if not arg.e\?Iup      { return _0 }
    if not arg.e\!Iup?Text { return _0 }
    return or [
            leq [_0:_long,arg.txt::_long],
            leq [arg.e\!Iup!Text::_long,arg.txt::_long]
           ]
}

type Iup = <
    Close    = (),
    Open     = (),
    Loop     = (),

    Message  = [_(char*), _(char*)],
    ShowXY   = [_(Ihandle*), _int, _int],

    Append   = [_(Ihandle*), _(Ihandle*)],
    GetFloat = [_(Ihandle*), _(char*), /_float],
    GetInt   = [_(Ihandle*), _(char*), /_int],
    GetStr   = [_(Ihandle*), _(char*), /_(char*)],
    SetFloat = [_(Ihandle*), _(char*), _float],
    SetInt   = [_(Ihandle*), _(char*), _int],
    SetStr   = [_(Ihandle*), _(char*), _(char*)],
    SetStrF  = [_(Ihandle*), _(char*), _(char*), _float],

    Button   = [/_(Ihandle*), _(char*)],
    Dialog   = [/_(Ihandle*), _(Ihandle*)],
    HBox     = /_(Ihandle*),
    VBox     = /_(Ihandle*),
    Label    = [/_(Ihandle*), _(char*)],
    List     = /_(Ihandle*),
    Text     = /_(Ihandle*)
>

native type _{
    int iup_cb_button (Ihandle* self) {
        Stack stk = { NULL, NULL, GLOBAL };
        Event evt = { CEU_EVENT_IUP, .Iup={CEU_EVENT_IUP_BUTTON, {.Button=self}} };
        bcast_event_block(&stk, GLOBAL, (_Event*)&evt);
        return IUP_DEFAULT;
    }
    int iup_cb_list (Ihandle* self, char *text, int item, int state) {
        Stack stk = { NULL, NULL, GLOBAL };
        Event evt = { CEU_EVENT_IUP, .Iup={CEU_EVENT_IUP_LIST, {.List={self,text,item,state}}} };
        bcast_event_block(&stk, GLOBAL, (_Event*)&evt);
        return IUP_DEFAULT;
    }
    int iup_cb_text (Ihandle* self) {
        Stack stk = { NULL, NULL, GLOBAL };
        Event evt = { CEU_EVENT_IUP, .Iup={CEU_EVENT_IUP_TEXT, {.Text=self}} };
        bcast_event_block(&stk, GLOBAL, (_Event*)&evt);
        return IUP_DEFAULT;
    }
    void output_iup (Iup arg) {
        switch (arg.tag) {
            case CEU_IUP_CLOSE:
                IupClose();
                break;
            case CEU_IUP_OPEN:
                IupOpen(NULL, NULL);
                break;
            case CEU_IUP_LOOP:
                IupMainLoop();
                break;

            case CEU_IUP_MESSAGE:
                IupMessage(arg.Message._1, arg.Message._2);
                break;
            case CEU_IUP_SHOWXY:
                IupShowXY(arg.ShowXY._1, arg.ShowXY._2, arg.ShowXY._3);
                break;

            case CEU_IUP_APPEND:
                IupAppend(arg.Append._1, arg.Append._2);
                break;
            case CEU_IUP_GETFLOAT:
                *arg.GetFloat._3 = IupGetFloat(arg.GetFloat._1, arg.GetFloat._2);
                break;
            case CEU_IUP_GETINT:
                *arg.GetInt._3 = IupGetInt(arg.GetInt._1, arg.GetInt._2);
                break;
            case CEU_IUP_GETSTR:
                *arg.GetStr._3 = IupGetAttribute(arg.GetStr._1, arg.GetStr._2);
                break;
            case CEU_IUP_SETFLOAT:
                IupSetFloat(arg.SetFloat._1, arg.SetFloat._2, arg.SetFloat._3);
                break;
            case CEU_IUP_SETINT:
                IupSetInt(arg.SetInt._1, arg.SetInt._2, arg.SetInt._3);
                break;
            case CEU_IUP_SETSTR:
                IupSetAttribute(arg.SetStr._1, arg.SetStr._2, arg.SetStr._3);
                break;
            case CEU_IUP_SETSTRF:
                IupSetStrf(arg.SetStrF._1, arg.SetStrF._2, arg.SetStrF._3, arg.SetStrF._4);
                break;

            case CEU_IUP_BUTTON:
                *arg.Button._1 = IupButton(arg.Button._2, NULL);
                IupSetCallback(*arg.Button._1, "ACTION", (Icallback) iup_cb_button);
                break;
            case CEU_IUP_DIALOG:
                *arg.Dialog._1 = IupDialog(arg.Dialog._2);
                break;
            case CEU_IUP_HBOX:
                *arg.HBox = IupHbox(NULL);
                break;
            case CEU_IUP_VBOX:
                *arg.VBox = IupVbox(NULL);
                break;
            case CEU_IUP_LABEL:
                *arg.Label._1 = IupLabel(arg.Label._2);
                break;
            case CEU_IUP_LIST:
                *arg.List = IupList(NULL);
                IupSetCallback(*arg.List, "ACTION", (Icallback) iup_cb_list);
                break;
            case CEU_IUP_TEXT:
                *arg.Text = IupText(NULL);
                IupSetCallback(*arg.Text, "VALUECHANGED_CB", (Icallback) iup_cb_text);
                break;

            default:
                assert(0 && "missing IUP operation");
        }
    }
}
