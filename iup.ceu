```:pre
#include <iup.h>

int c_iup_action_cb (Ihandle* h) {
    CEU_Value hh = { CEU_VALUE_POINTER, {.Pointer=h} };
    CEU_Value* args[1] = { &hh };
    CEU_Block block = { 1, NULL, { NULL, NULL } };
    CEU_Frame frame = { &ceu_mem->iup_action_cb.Dyn->Proto, &block, NULL, {} };
    ceu_mem->iup_action_cb.Dyn->Proto.f(&frame, 1, args);
    return IUP_DEFAULT;
}
int c_iup_value_cb (Ihandle* h) {
    CEU_Value hh = { CEU_VALUE_POINTER, {.Pointer=h} };
    CEU_Value* args[1] = { &hh };
    CEU_Block block = { 1, NULL, { NULL, NULL } };
    CEU_Frame frame = { &ceu_mem->iup_value_cb.Dyn->Proto, &block, NULL, {} };
    ceu_mem->iup_value_cb.Dyn->Proto.f(&frame, 1, args);
    return IUP_DEFAULT;
}
int c_iup_list_action_cb (Ihandle* h, char *text, int item, int state) {
    CEU_Value hh = { CEU_VALUE_POINTER, {.Pointer=h} };
    CEU_Value it = { CEU_VALUE_NUMBER,  {.Number=item} };
    CEU_Value st = { CEU_VALUE_BOOL,    {.Bool=state} };
    CEU_Value* args[] = { &hh, &it, &st };
    CEU_Block block = { 1, NULL, { NULL, NULL } };
    CEU_Frame frame = { &ceu_mem->iup_list_action_cb.Dyn->Proto, &block, NULL, {} };
    ceu_mem->iup_list_action_cb.Dyn->Proto.f(&frame, 3, args);
    return IUP_DEFAULT;
}
```

;; INIT

func iup_open () {
    `IupOpen(NULL, NULL);`
}

func iup_close () {
    `IupClose();`
}

func iup_loop () {
    `IupMainLoop();`
}

;; GET / SET

func iup_get_pointer (h, name) {
    `:pointer IupGetAttribute($h.Pointer, ceu_tag_to_string($name.Tag)+1)`
}
func iup_get_bool (h, name) {
    `:bool IupGetInt($h.Pointer, ceu_tag_to_string($name.Tag)+1)`
}
func iup_get_number (h, name) {
    `:number IupGetInt($h.Pointer, ceu_tag_to_string($name.Tag)+1)`
}

func iup_set(h, name, value) {
    var tag = tags(value)
    ifs {
        tag == :tag     -> `IupSetAttribute($h.Pointer, ceu_tag_to_string($name.Tag)+1,ceu_tag_to_string($value.Tag)+1);`
        tag == :bool    -> `IupSetInt($h.Pointer, ceu_tag_to_string($name.Tag)+1, $value.Bool);`
        tag == :number  -> `IupSetFloat($h.Pointer, ceu_tag_to_string($name.Tag)+1, $value.Number);`
        tag == :pointer -> `IupSetAttribute($h.Pointer, ceu_tag_to_string($name.Tag)+1, $value.Pointer);`
        else            -> `IupSetAttribute($h.Pointer, ceu_tag_to_string($name.Tag)+1, $value.Dyn->Vector.mem);`
    }
}

;; CONTROLS

func iup_action_cb (h) {
    broadcast in :global, @[(:obj,h),(:type,:action)]
}
func iup_value_cb (h) {
    broadcast in :global, @[(:obj,h),(:type,:value)]
}
func iup_list_action_cb (h, item, state) {
    broadcast in :global, @[(:obj,h),(:type,:action),(:item,item),(:state,state)]
}

func iup_button (label) {
    var ptr = `:pointer IupButton($label.Dyn->Vector.mem, NULL)`
    `IupSetCallback($ptr.Pointer, "ACTION", (Icallback) c_iup_action_cb);`
    ptr
}

func iup_label (label) {
    `:pointer IupLabel($label.Dyn->Vector.mem)`
}

func iup_list () {
    var ptr = `:pointer IupList(NULL)`
    `IupSetCallback($ptr.Pointer, "ACTION", (Icallback) c_iup_list_action_cb);`
    ptr
}

func iup_text () {
    var ptr = `:pointer IupText(NULL)`
    `IupSetCallback($ptr.Pointer, "VALUECHANGED_CB", (Icallback) c_iup_value_cb);`
    ptr
}

;; CONTAINERS

func iup_hbox () {
    `:pointer IupHbox(NULL)`
}

func iup_vbox () {
    `:pointer IupVbox(NULL)`
}

func iup_append (h, child) {
    `:pointer IupAppend($h.Pointer, $child.Pointer)`
}

;; DIALOGS

func iup_dialog (h) {
    `:pointer IupDialog($h.Pointer)`
}

func iup_show_xy (h, x, y) {
    `:number IupShowXY($h.Pointer, $x.Number, $y.Number)`
}

;; AUX

func evt_obj? (obj) {
    tags(evt)==:dict and evt.obj==obj
}

func evt_type? (tag) {
    tags(evt)==:dict and evt.type==tag
}
